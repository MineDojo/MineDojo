<?xml version="1.0" encoding="UTF-8" ?>

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           targetNamespace="http://ProjectMalmo.microsoft.com"
           xmlns="http://ProjectMalmo.microsoft.com"
           xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
           elementFormDefault="qualified"
           jaxb:version="2.1"
           version="0.37">

    <xs:include schemaLocation="Types.xsd"/>
    <xs:include schemaLocation="Mission.xsd"/>

    <xs:complexType name="Pos">
        <xs:annotation>
            <xs:documentation>
                An absolute position in the 3D Minecraft world.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="x" type="xs:decimal" use="required"/>
        <xs:attribute name="y" type="xs:decimal" use="required"/>
        <xs:attribute name="z" type="xs:decimal" use="required"/>
    </xs:complexType>

    <xs:complexType name="PosAndDirection">
        <xs:annotation>
            <xs:documentation>
                An absolute position in the 3D Minecraft world that includes yaw and pitch.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="Pos">
                <xs:attribute name="yaw" use="optional" default="0">
                    <xs:annotation>
                        <xs:documentation>
                            Defaults to facing South (0). North is 180.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:decimal">
                            <xs:minInclusive value="-360"/>
                            <xs:maxInclusive value="360"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
                <xs:attribute name="pitch" use="optional" default="0">
                    <xs:annotation>
                        <xs:documentation>
                            Defaults to looking straight ahead (0). +90 = look down. -90 = look up.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:restriction base="xs:decimal">
                            <xs:minInclusive value="-90"/>
                            <xs:maxInclusive value="90"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--=============================================================================================================-->
    <!--=========================================== SERVER-SIDE HANDLERS ============================================-->
    <!--=============================================================================================================-->

    <!--============================================= WORLD GENERATORS ==============================================-->

    <xs:element name="FlatWorldGenerator">
        <xs:annotation>
            <xs:documentation>
                Generates a superflat world with a specified preset string - see e.g.
                [[http://www.minecraft101.net/superflat/]]
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="generatorString" use="optional" type="xs:string" default="3;7,2*3,2;1;village">
                <xs:annotation>
                    <xs:documentation>
                        The superflat customization preset string.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="forceReset" use="optional" type="xs:boolean" default="false">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world to be reloaded, otherwise the current world will be used
                        (provided it matches the requested generator string).
                        Force reloading is slow, but will guarantee that no world changes will carry over between
                        missions.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="seed" use="optional" type="xs:string" default="">
                <xs:annotation>
                    <xs:documentation>
                        The world seed - leave blank (default) to get a random world.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destroyAfterUse" use="optional" type="xs:boolean" default="true">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world data files to be deleted after the mission is done.
                        Enabling this setting prevents the disk being filled with old worlds.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:element name="DefaultWorldGenerator">
        <xs:annotation>
            <xs:documentation>
                Generates the default terrain.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="seed" use="optional" type="xs:string" default="">
                <xs:annotation>
                    <xs:documentation>
                        The world seed - leave blank (default) to get a random world.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="forceReset" use="optional" type="xs:boolean" default="false">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world to be reloaded, otherwise the current world will be used
                        (provided it matches the requested seed).
                        Force reloading is slow, but will guarantee that no world changes will carry over between
                        missions.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="generatorOptions" use="optional" type="xs:string" default="">
                <xs:annotation>
                    <xs:documentation>
                        Set this to the desired world generator string for your minecraft world.
                        See https://minecraft.tools/en/custom.php for examples.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destroyAfterUse" use="optional" type="xs:boolean" default="true">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world data files to be deleted after the mission is done.
                        Enabling this setting prevents the disk being filled with old worlds.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:element name="FileWorldGenerator">
        <xs:annotation>
            <xs:documentation>
                Loads a saved world from disk. You can find the saved worlds in "{{{ Minecraft\run\saves}}}". Use the
                full path to one of those folders.

                If Minecraft is running on a different machine then copy the folder to a readable network location and
                update the path accordingly. Example:

                {{{&lt;FileWorldGenerator src=&quot;\\\\machine-id\\shared\\ProjectMalmo\\saved_maps\\arena&quot; /&gt;}}}
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="src" use="required" type="xs:anyURI">
                <xs:annotation>
                    <xs:documentation>
                        The path to the saved world folder.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="forceReset" use="optional" type="xs:boolean" default="false">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world to be reloaded, otherwise the current world will be used
                        (provided it matches the requested source filename).
                        Force reloading is slow, but will guarantee that no world changes will carry over between
                        missions.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destroyAfterUse" use="optional" type="xs:boolean" default="true">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world data files to be deleted after the mission is done.
                        Enabling this setting prevents the disk being filled with old worlds.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:element name="BiomeGenerator">
        <xs:annotation>
            <xs:documentation>
                Generates a survival world with the specified biome.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="seed" use="optional" type="xs:string" default="">
                <xs:annotation>
                    <xs:documentation>
                        The world seed - leave blank (default) to get a random world.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="biome" use="optional" type="xs:int">
                <xs:annotation>
                    <xs:documentation>
                        The biome type for the world. Each chunk will be loaded with the biome specified.

                        If left blank, the world will be a normal survival world.

                        Biome ID #'s can be found here: https://minecraft.wiki/w/Biome#Biome_IDs
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="forceReset" use="optional" type="xs:boolean" default="false">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world to be reloaded, otherwise the current world will be used
                        (provided it matches the requested seed).
                        Force reloading is slow, but will guarantee that no world changes will carry over between
                        missions.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destroyAfterUse" use="optional" type="xs:boolean" default="true">
                <xs:annotation>
                    <xs:documentation>
                        Set this to true to force the world data files to be deleted after the mission is done.
                        Enabling this setting prevents the disk being filled with old worlds.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <!--============================================= WORLD DECORATORS ==============================================-->

    <xs:simpleType name="BlockList">
        <xs:list itemType="BlockType"/>
    </xs:simpleType>

    <xs:simpleType name="ItemList">
        <xs:list itemType="ItemType"/>
    </xs:simpleType>

    <xs:simpleType name="BlockOrItemList">
        <xs:list itemType="BlockOrItem"/>
    </xs:simpleType>

    <xs:simpleType name="ColourList">
        <xs:list itemType="Colour"/>
    </xs:simpleType>

    <xs:simpleType name="VariantList">
        <xs:list itemType="Variation"/>
    </xs:simpleType>

    <xs:complexType name="MazeBlock">
        <xs:attribute name="type" use="optional" type="BlockList"/>
        <xs:attribute name="variant" use="optional" type="VariantList"/>
        <xs:attribute name="colour" use="optional" type="ColourList"/>
        <xs:attribute name="height" use="optional" type="xs:int" default="1"/>
        <xs:attribute name="heightVariance" use="optional" type="xs:int" default="0"/>
    </xs:complexType>

    <xs:complexType name="MazeTerminus">
        <xs:complexContent>
            <xs:extension base="MazeBlock">
                <xs:attribute name="fixedToEdge" use="optional" type="xs:boolean" default="false"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="SnakeBlock">
        <xs:attribute name="type" use="optional" type="BlockList"/>
        <xs:attribute name="variant" use="optional" type="VariantList"/>
        <xs:attribute name="colour" use="optional" type="ColourList"/>
        <xs:attribute name="lifetime" use="optional" type="xs:int" default="1"/>
        <xs:attribute name="lifetimeVariance" use="optional" type="xs:int" default="0"/>
    </xs:complexType>

    <xs:element name="MovingTargetDecorator">
        <xs:annotation>
            <xs:documentation>
                Creates a moving two-block target which takes random moves within a specified arena. Can be linked to
                the turn scheduler.
                This can be made more general in the future, but is currently tailored specifically for the Malmo
                collaborative challenge.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ArenaBounds" type="UnnamedGridDefinition">
                    <xs:annotation>
                        <xs:documentation>
                            Define the bounds of the arena within which the target can move.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="StartPos" type="Pos"/>
                <xs:element name="Seed">
                    <xs:annotation>
                        <xs:documentation>
                            The master seed for the random number generator used to move the target.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:annotation>
                            <xs:documentation>
                                Either an integer number, or the string "random".
                            </xs:documentation>
                        </xs:annotation>
                        <xs:restriction base="xs:string">
                            <xs:pattern value="random|[0-9]+"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="UpdateSpeed">
                    <xs:annotation>
                        <xs:documentation>
                            The length, in ticks, between each update, or the string "turnbased" to use the turn
                            scheduler.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:annotation>
                            <xs:documentation>
                                Either an integer number, or the string "turnbased".
                            </xs:documentation>
                        </xs:annotation>
                        <xs:restriction base="xs:string">
                            <xs:pattern value="turnbased|[0-9]+"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="PermeableBlocks" type="BlockSpec"/>
                <xs:element name="BlockType" type="DrawBlockBasedObjectType"/>
            </xs:all>
            <xs:attribute name="requiresAirAbove" type="xs:boolean" default="true"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="SnakeDecorator">
        <xs:annotation>
            <xs:documentation>
                Adds a snake made of blocks, that grows at one end and shrinks at the other.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="Seed">
                    <xs:annotation>
                        <xs:documentation>
                            The master seed for the random number generator used to make the snake.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:annotation>
                            <xs:documentation>
                                Either an integer number, or the string "random".
                            </xs:documentation>
                        </xs:annotation>
                        <xs:restriction base="xs:string">
                            <xs:pattern value="random|[0-9]+"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="MaterialSeed" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Optional seed for determining block types.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:annotation>
                            <xs:documentation>
                                Either an integer number, or the string "random".
                            </xs:documentation>
                        </xs:annotation>
                        <xs:restriction base="xs:string">
                            <xs:pattern value="random|[0-9]+"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="FreshBlock" type="SnakeBlock"/>
                <xs:element name="StaleBlock" type="SnakeBlock"/>
                <xs:element name="GapProbability">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="xs:decimal">
                                <xs:attribute name="variance" type="xs:decimal" use="optional" default="0"/>
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
                <xs:element name="StairsProbability">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="xs:decimal">
                                <xs:attribute name="variance" type="xs:decimal" use="optional" default="0"/>
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
                <xs:element name="TurnProbability">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="xs:decimal">
                                <xs:attribute name="variance" type="xs:decimal" use="optional" default="0"/>
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
                <xs:element name="SizeAndPosition">
                    <xs:complexType>
                        <xs:attribute name="xOrigin" type="xs:int" default="0"/>
                        <xs:attribute name="yOrigin" type="xs:int" default="55"/>
                        <xs:attribute name="zOrigin" type="xs:int" default="0"/>
                        <xs:attribute name="yMin" type="xs:int" default="32"/>
                        <xs:attribute name="yMax" type="xs:int" default="250"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="SpeedInTicks" type="xs:int" default="6"/>
                <xs:element name="MaxLength" type="xs:int" default="30"/>
                <xs:element name="MaxStairLength" type="xs:int" default="20"/>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="MazeDecorator">
        <xs:annotation>
            <xs:documentation>
                Adds a maze into the world.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="Seed">
                    <xs:annotation>
                        <xs:documentation>
                            The master seed for the random number generator used to make the maze.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:annotation>
                            <xs:documentation>
                                Either an integer number, or the string "random".
                            </xs:documentation>
                        </xs:annotation>
                        <xs:restriction base="xs:string">
                            <xs:pattern value="random|[0-9]+"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="MaterialSeed" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Seed for the random number generator for determining block types - omit to allow master seed
                            to control block types.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:simpleType>
                        <xs:annotation>
                            <xs:documentation>
                                Either an integer number, or the string "random".
                            </xs:documentation>
                        </xs:annotation>
                        <xs:restriction base="xs:string">
                            <xs:pattern value="random|[0-9]+"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="AllowDiagonalMovement" type="xs:boolean" default="false"/>
                <xs:element name="SizeAndPosition">
                    <xs:complexType>
                        <xs:attribute name="width" type="xs:int" default="10"/>
                        <xs:attribute name="length" type="xs:int" default="10"/>
                        <xs:attribute name="height" type="xs:int" default="100"/>
                        <xs:attribute name="scale" type="xs:int" default="1"/>
                        <xs:attribute name="xOrigin" type="xs:int" default="0"/>
                        <xs:attribute name="yOrigin" type="xs:int" default="55"/>
                        <xs:attribute name="zOrigin" type="xs:int" default="0"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="StartBlock" type="MazeTerminus"/>
                <xs:element name="EndBlock" type="MazeTerminus"/>
                <xs:element name="PathBlock" type="MazeBlock"/>
                <xs:element name="FloorBlock" type="MazeBlock"/>
                <xs:element name="GapBlock" type="MazeBlock"/>
                <xs:element name="OptimalPathBlock" type="MazeBlock" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Omit this element if you want the optimal path to be unmarked.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="SubgoalBlock" type="MazeBlock" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Omit this element if you want the subgoal points to be unmarked.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="Waypoints" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:choice>
                            <xs:element name="WaypointBlock" type="MazeBlock"/>
                            <xs:element name="WaypointItem" type="BlockOrItemSpec"/>
                        </xs:choice>
                        <xs:attribute name="quantity" type="xs:int" use="required"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="GapProbability">
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="xs:decimal">
                                <xs:attribute name="variance" type="xs:decimal" use="optional" default="0"/>
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
                <xs:element name="AddQuitProducer" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:attribute name="description" type="xs:string" use="optional" default=""/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="AddNavigationObservations" minOccurs="0" maxOccurs="1">
                    <xs:complexType/>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="DrawObjectType">
        <xs:annotation>
            <xs:documentation>
                Base class for all draw objects.
            </xs:documentation>
        </xs:annotation>
    </xs:complexType>

    <xs:complexType name="DrawBlockBasedObjectType">
        <xs:annotation>
            <xs:documentation>
                Base class for all block-based draw objects.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawObjectType">
                <xs:attribute name="type" type="BlockType" use="required"/>
                <xs:attribute name="variant" type="Variation" use="optional"/>
                <xs:attribute name="colour" type="Colour" use="optional"/>
                <xs:attribute name="face" type="Facing" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:element name="DrawingDecorator">
        <xs:annotation>
            <xs:documentation>
                Draws structures into the world.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="DrawObjectType" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="DrawBlock">
        <xs:annotation>
            <xs:documentation>
                Specify a block by location and type.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawBlockBasedObjectType">
                <xs:attribute name="x" type="xs:int" use="required"/>
                <xs:attribute name="y" type="xs:int" use="required"/>
                <xs:attribute name="z" type="xs:int" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="DrawItem">
        <xs:annotation>
            <xs:documentation>
                Specify an item by location and type.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawObjectType">
                <xs:attribute name="x" type="xs:int" use="required"/>
                <xs:attribute name="y" type="xs:int" use="required"/>
                <xs:attribute name="z" type="xs:int" use="required"/>
                <xs:attribute name="type" type="BlockOrItem" use="required"/>
                <xs:attribute name="variant" type="Variation" use="optional"/>
                <xs:attribute name="colour" type="Colour" use="optional"/>
                <xs:attribute name="face" type="Facing" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="ContainedObjectType">
        <xs:attribute name="type" use="required" type="BlockOrItem"/>
        <xs:attribute name="variant" use="optional" type="Variation"/>
        <xs:attribute name="colour" use="optional" type="Colour"/>
        <xs:attribute name="quantity" type="xs:int" use="optional" default="1"/>
    </xs:complexType>

    <xs:complexType name="DrawContainer">
        <xs:annotation>
            <xs:documentation>
                Specify a container item by location and type and contents.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawObjectType">
                <xs:choice minOccurs="1" maxOccurs="unbounded">
                    <xs:element name="Object" type="ContainedObjectType"/>
                </xs:choice>
                <xs:attribute name="x" type="xs:int" use="required"/>
                <xs:attribute name="y" type="xs:int" use="required"/>
                <xs:attribute name="z" type="xs:int" use="required"/>
                <xs:attribute name="type" type="ContainerType" use="required"/>
                <xs:attribute name="variant" type="Variation" use="optional"/>
                <xs:attribute name="colour" type="Colour" use="optional"/>
                <xs:attribute name="face" type="Facing" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="DrawSign">
        <xs:annotation>
            <xs:documentation>
                Draw a sign at the required location with the specified text.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawObjectType">
                <xs:attribute name="x" type="xs:int" use="required"/>
                <xs:attribute name="y" type="xs:int" use="required"/>
                <xs:attribute name="z" type="xs:int" use="required"/>
                <xs:attribute name="type" type="SignType" use="required"/>
                <xs:attribute name="variant" type="Variation" use="optional"/>
                <xs:attribute name="colour" type="Colour" use="optional"/>
                <xs:attribute name="face" type="Facing" use="optional"/>
                <xs:attribute name="line1" type="xs:string" use="optional"/>
                <xs:attribute name="line2" type="xs:string" use="optional"/>
                <xs:attribute name="line3" type="xs:string" use="optional"/>
                <xs:attribute name="line4" type="xs:string" use="optional"/>
                <xs:attribute name="rotation" type="xs:int" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="DrawEntity">
        <xs:annotation>
            <xs:documentation>
                Specify an entity by location and type.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawObjectType">
                <xs:attribute name="x" type="xs:decimal" use="required"/>
                <xs:attribute name="y" type="xs:decimal" use="required"/>
                <xs:attribute name="z" type="xs:decimal" use="required"/>
                <xs:attribute name="type" type="SpawnableTypes" use="required"/>
                <xs:attribute name="yaw" type="xs:decimal" use="optional" default="0"/>
                <xs:attribute name="pitch" type="xs:decimal" use="optional" default="0"/>
                <xs:attribute name="xVel" type="xs:decimal" use="optional" default="0"/>
                <xs:attribute name="yVel" type="xs:decimal" use="optional" default="0"/>
                <xs:attribute name="zVel" type="xs:decimal" use="optional" default="0"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="DrawCuboid">
        <xs:annotation>
            <xs:documentation>
                Specify a filled cuboid by inclusive coordinates and block type.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawBlockBasedObjectType">
                <xs:attribute name="x1" type="xs:int" use="required"/>
                <xs:attribute name="y1" type="xs:int" use="required"/>
                <xs:attribute name="z1" type="xs:int" use="required"/>
                <xs:attribute name="x2" type="xs:int" use="required"/>
                <xs:attribute name="y2" type="xs:int" use="required"/>
                <xs:attribute name="z2" type="xs:int" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="DrawSphere">
        <xs:annotation>
            <xs:documentation>
                Specify a filled sphere by centre coordinates and inclusive radius.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawBlockBasedObjectType">
                <xs:attribute name="x" type="xs:int" use="required"/>
                <xs:attribute name="y" type="xs:int" use="required"/>
                <xs:attribute name="z" type="xs:int" use="required"/>
                <xs:attribute name="radius" type="xs:int" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="DrawLine">
        <xs:annotation>
            <xs:documentation>
                Specify a line by start and end coordinates and thickness.
            </xs:documentation>
        </xs:annotation>
        <xs:complexContent>
            <xs:extension base="DrawBlockBasedObjectType">
                <xs:attribute name="x1" type="xs:int" use="required"/>
                <xs:attribute name="y1" type="xs:int" use="required"/>
                <xs:attribute name="z1" type="xs:int" use="required"/>
                <xs:attribute name="x2" type="xs:int" use="required"/>
                <xs:attribute name="y2" type="xs:int" use="required"/>
                <xs:attribute name="z2" type="xs:int" use="required"/>
                <xs:attribute name="steptype" type="BlockType" use="optional"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:element name="DrawObjectType" type="DrawObjectType"/>
    <xs:element name="DrawEntity" type="DrawEntity" substitutionGroup="DrawObjectType"/>
    <xs:element name="DrawItem" type="DrawItem" substitutionGroup="DrawObjectType"/>
    <xs:element name="DrawLine" type="DrawLine" substitutionGroup="DrawObjectType"/>
    <xs:element name="DrawSphere" type="DrawSphere" substitutionGroup="DrawObjectType"/>
    <xs:element name="DrawBlock" type="DrawBlock" substitutionGroup="DrawObjectType"/>
    <xs:element name="DrawCuboid" type="DrawCuboid" substitutionGroup="DrawObjectType"/>
    <xs:element name="DrawContainer" type="DrawContainer" substitutionGroup="DrawObjectType"/>
    <xs:element name="DrawSign" type="DrawSign" substitutionGroup="DrawObjectType"/>

    <xs:element name="ClassroomDecorator">
        <xs:annotation>
            <xs:documentation>
                Adds a series of joined rooms into the world.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice>
                <xs:element name="complexity">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="building" type="ZeroToOne"/>
                            <xs:element name="path" type="ZeroToOne"/>
                            <xs:element name="division" type="ZeroToOne"/>
                            <xs:element name="obstacle" type="ZeroToOne"/>
                            <xs:element name="hint" type="ZeroToOne"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name="specification">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="width" type="BuildingSize"/>
                            <xs:element name="height" type="BuildingSize"/>
                            <xs:element name="length" type="BuildingSize"/>
                            <xs:element name="pathLength" type="NonNegative"/>
                            <xs:element name="divisions">
                                <xs:complexType>
                                    <xs:all>
                                        <xs:element name="southNorth" type="NonNegative"/>
                                        <xs:element name="eastWest" type="NonNegative"/>
                                        <xs:element name="aboveBelow" type="NonNegative"/>
                                    </xs:all>
                                </xs:complexType>
                            </xs:element>
                            <xs:element name="horizontalObstacles" type="HorizontalObstacles"/>
                            <xs:element name="verticalObstacles" type="VerticalObstacles"/>
                            <xs:element name="hintLikelihood" type="ZeroToOne"/>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
            </xs:choice>
            <xs:attribute name="seed" type="xs:string" use="optional"/>
            <xs:attribute name="palette" type="PaletteEnum" use="optional"/>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="PaletteEnum">
        <xs:restriction base="xs:string">
            <xs:enumeration value="default"/>
            <xs:enumeration value="random"/>
            <xs:enumeration value="dungeon"/>
            <xs:enumeration value="pyramid"/>
            <xs:enumeration value="igloo"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="HorizontalObstacles">
        <xs:all>
            <xs:element name="gap" type="NonNegative"/>
            <xs:element name="bridge" type="NonNegative"/>
            <xs:element name="door" type="NonNegative"/>
            <xs:element name="puzzle" type="NonNegative"/>
            <xs:element name="jump" type="NonNegative"/>
        </xs:all>
    </xs:complexType>

    <xs:complexType name="VerticalObstacles">
        <xs:all>
            <xs:element name="stairs" type="NonNegative"/>
            <xs:element name="ladder" type="NonNegative"/>
            <xs:element name="jump" type="NonNegative"/>
        </xs:all>
    </xs:complexType>

    <xs:simpleType name="BuildingSize">
        <xs:restriction base="xs:int">
            <xs:minInclusive value="7"/>
            <xs:maxInclusive value="50"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="ZeroToOne">
        <xs:restriction base="xs:double">
            <xs:minInclusive value="0"/>
            <xs:maxInclusive value="1"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="NonNegative">
        <xs:restriction base="xs:int">
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="AnimationDecorator">
        <xs:annotation>
            <xs:documentation>
                Basic animation created by repeatedly applying a DrawingDecorator at different positions.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:choice>
                    <xs:element name="Parametric">
                        <xs:annotation>
                            <xs:documentation>
                                Create an animation where the (x,y,z) position are determined by parametric equations.
                                Recognised tokens are:

                                * basic arithmetic operations: +, -, /, *, % (modulo), ^ (to the power of)
                                * basic trig: sin, cos, tan, asin, acos, atan
                                * abs (absolute value)
                                * rand - replaces with a random float between 0 and 1
                                * t - the integer time variable, incremented with each time interval

                                For example, to create a structure which orbits in the x-z plane about the point
                                (100,100,100) at a radius of 20, use:
                                "100+20*cos(t)" and "100+20*sin(t)" for the x and z strings.

                                The parser is not robust to mismatched brackets, typos, unrecognised tokens etc, and
                                will fail silently.
                            </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:all>
                                <xs:element name="x" type="xs:string"/>
                                <xs:element name="y" type="xs:string"/>
                                <xs:element name="z" type="xs:string"/>
                            </xs:all>
                            <xs:attribute name="seed">
                                <xs:annotation>
                                    <xs:documentation>
                                        The master seed for the random number generator used for any stochastic
                                        elements.
                                    </xs:documentation>
                                </xs:annotation>
                                <xs:simpleType>
                                    <xs:annotation>
                                        <xs:documentation>
                                            Either an integer number, or the string "random".
                                        </xs:documentation>
                                    </xs:annotation>
                                    <xs:restriction base="xs:string">
                                        <xs:pattern value="random|[0-9]+"/>
                                    </xs:restriction>
                                </xs:simpleType>
                            </xs:attribute>
                        </xs:complexType>
                    </xs:element>
                    <xs:element name="Linear">
                        <xs:annotation>
                            <xs:documentation>
                                Create an animation where the (x,y,z) position is determined by the starting position, a
                                constant velocity, and a bounding box.

                                Each time step, the position is updated by adding the velocity values. If the object
                                goes outside of the bounding box in one dimension, that dimension's velocity will be
                                flipped to reverse the direction.
                            </xs:documentation>
                        </xs:annotation>
                        <xs:complexType>
                            <xs:all>
                                <xs:element name="CanvasBounds" type="UnnamedGridDefinition">
                                    <xs:annotation>
                                        <xs:documentation>
                                            Define the bounds of the canvas within which to move the object.
                                        </xs:documentation>
                                    </xs:annotation>
                                </xs:element>
                                <xs:element name="InitialPos" type="Pos">
                                    <xs:annotation>
                                        <xs:documentation>
                                            Define the starting position of the drawing's origin.
                                        </xs:documentation>
                                    </xs:annotation>
                                </xs:element>
                                <xs:element name="InitialVelocity" type="Pos">
                                    <xs:annotation>
                                        <xs:documentation>
                                            Define the initial velocity of the drawing's origin.
                                        </xs:documentation>
                                    </xs:annotation>
                                </xs:element>
                            </xs:all>
                        </xs:complexType>
                    </xs:element>
                </xs:choice>
                <xs:element ref="DrawingDecorator">
                    <xs:annotation>
                        <xs:documentation>
                            Define the drawing, relative to (0,0,0), which will be drawn for each frame of the
                            animation.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="ticksPerUpdate" type="xs:int" default="1">
                <xs:annotation>
                    <xs:documentation>
                        The number of server ticks between each update of the animation.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:element name="BuildBattleDecorator">
        <xs:annotation>
            <xs:documentation>
                Sets up a build battle area, with a source structure that can't be edited, and a goal structure, with
                optional recolouring of blocks to indicate correct/incorrect placement.

                NOTE: Make sure to add a {{{ RewardForStructureCopying }}} handler to the AgentHandlers if you want your
                agent to be rewarded for contributing to the build.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="GoalStructureBounds" type="UnnamedGridDefinition">
                    <xs:annotation>
                        <xs:documentation>
                            Define the bounds of the structure to be copied. Anything in this volume when the mission
                            starts will be used as the blueprint - eg anything drawn here using the
                            {{{ DrawingDecorator }}}, etc.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="PlayerStructureBounds" type="UnnamedGridDefinition">
                    <xs:annotation>
                        <xs:documentation>
                            Define the bounds in which the agent should build their copy.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="BlockTypeOnCorrectPlacement" type="DrawBlockBasedObjectType" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            If present, correctly placed blocks (in the source and the copy) will be changed to this
                            block type.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="BlockTypeOnIncorrectPlacement" type="DrawBlockBasedObjectType" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            If present, incorrectly placed blocks (in the copy only) will be changed to this block type.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="RandomPlacement">
        <xs:all>
            <xs:annotation>
                <xs:documentation>
                    Helps specify where random blocks should be placed in the world.
                </xs:documentation>
            </xs:annotation>
            <xs:element name="origin" type="Pos" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Specifies the origin point or spawn point in the Minecraft world.

                        If omitted, set to the world spawn point.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="minRadius" type="xs:decimal" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Specifies the minumum radius of the circle around which the block may be randomly placed.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="maxRadius" type="xs:decimal" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Specifies the maximum radius of the circle around which the block may be randomly placed.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="block" type="BlockType" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Specifies the block type of the block to be randomly placed.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="placement" minOccurs="0" maxOccurs="1">
                <xs:simpleType>
                    <xs:annotation>
                        <xs:documentation>
                            Specifies the placement behavior of the block. Default is "surface."

                            String of "sphere" will place equally randomly in a sphere of radius specified.

                            String of "circle" will place randomly in a circle at the y-coordinate specified.

                            String of "surface" will place randomly in a circle, then raise to the highest available
                            block on the surface.
                        </xs:documentation>
                    </xs:annotation>
                    <xs:restriction base="xs:string">
                        <xs:enumeration value="sphere"/>
                        <xs:enumeration value="circle"/>
                        <xs:enumeration value="surface"/>
                        <xs:enumeration value="fixed_surface"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="randomizedRadius" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                <xs:annotation>
                    <xs:documentation>
                        Sets whether or not the target block radius should be randomized within a certain radius.
                        If false, will set the default target radius to the given radius.
                        If true, will set the default target radius randomly within the bound specified below.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="minRandomizedRadius" type="xs:decimal" minOccurs="0" maxOccurs="1" default="10">
                <xs:annotation>
                    <xs:documentation>
                        The minimum distance for a randomly placed target block.

                        If omitted, and randomization of radius enabled, set to 10 blocks.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="maxRandomizedRadius" type="xs:decimal" minOccurs="0" maxOccurs="1" default="64">
                <xs:annotation>
                    <xs:documentation>
                        The maximum distance for a randomly placed target block.

                        If omitted, and randomization of radius enabled, set to 64 blocks.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:all>
    </xs:complexType>

    <xs:element name="MarkingDecorator">
        <xs:annotation>
            <xs:documentation>
                Adds two distinct "marker" blocks diagonally at world start. Can be used to mark a build area for an
                agent
                receiving an exact blueprint

                Agent is teleported to a random point within a radius around the marker blocks.

                This can be used together with ObservationFromGrid to provide an observation for the structure placed
                around the marker blocks.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="origin" type="Pos" minOccurs="0" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation>
                            Specifies the origin point or spawn point in the Minecraft world.

                            If omitted, set to the world spawn point.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="block1" type="BlockType" minOccurs="1" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation>
                            Specifies the block type of the first marker block to be randomly placed.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="block2" type="BlockType" minOccurs="1" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation>
                            Specifies the block type of the second marker block to be randomly placed.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="placement" minOccurs="0" maxOccurs="1">
                    <xs:simpleType>
                        <xs:annotation>
                            <xs:documentation>
                                Specifies the placement behavior of the agent. Default is "surface."

                                String of "sphere" will place equally randomly in a sphere of radius specified.

                                String of "circle" will place randomly in a circle at the y-coordinate specified.

                                String of "surface" will place randomly in a circle, then raise to the highest available
                                block on the surface.
                            </xs:documentation>
                        </xs:annotation>
                        <xs:restriction base="xs:string">
                            <xs:enumeration value="sphere"/>
                            <xs:enumeration value="circle"/>
                            <xs:enumeration value="surface"/>
                            <xs:enumeration value="fixed_surface"/>
                        </xs:restriction>
                    </xs:simpleType>
                </xs:element>
                <xs:element name="randomizedRadius" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false">
                    <xs:annotation>
                        <xs:documentation>
                            Sets whether or not the agent radius should be randomized within a certain radius.
                            If false, will set the default target radius to the given radius.
                            If true, will set the default target radius randomly within the bound specified below.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="minRandomizedRadius" type="xs:decimal" minOccurs="0" maxOccurs="1" default="10">
                    <xs:annotation>
                        <xs:documentation>
                            The minimum distance for a randomly placed agent.

                            If omitted, and randomization of radius enabled, set to 10 blocks.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="maxRandomizedRadius" type="xs:decimal" minOccurs="0" maxOccurs="1" default="64">
                    <xs:annotation>
                        <xs:documentation>
                            The maximum distance for a randomly placed agent.

                            If omitted, and randomization of radius enabled, set to 64 blocks.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="NavigationDecorator">
        <xs:annotation>
            <xs:documentation>
                Adds a specified block to the world and sets compass to that block.

                Block is placed randomly along a radius around the origin specified.

                Can force the block to appear at the highest available y-value.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="randomPlacementProperties" type="RandomPlacement">
                    <xs:annotation>
                        <xs:documentation>
                            Properties for placing a block in the world randomly.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="randomizeCompassLocation" type="xs:boolean" minOccurs="1" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation>
                            Sets whether or not the compass location should be randomized within a certain radius.
                            If false, will set the compass location to the block that was randomly placed.
                            If true, will set the compass location to a random spot within the radius specified below.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="minRandomizedDistance" type="xs:decimal" minOccurs="0" maxOccurs="1" default="0">
                    <xs:annotation>
                        <xs:documentation>
                            The minimum distance a randomized compass location must be from the block that was randomly
                            placed.

                            If omitted, set to 0 blocks.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="maxRandomizedDistance" type="xs:decimal" minOccurs="0" maxOccurs="1" default="8">
                    <xs:annotation>
                        <xs:documentation>
                            The maximum distance a randomized compass location must be from the block that was randomly
                            placed.

                            If omitted, set to 8 blocks.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="RandomizedStartDecorator">
        <xs:annotation>
            <xs:documentation>
                Adds a random starting position for agents uniformly chosen at random from (0,0) to (Integer.max,
                Inteegr.max)

                Spawn height is chosen using the default minecraft spawning rules - getTopSolidOrLiquidBlock()
                preventing spawning

                on trees or non-solid blocks
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="test" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>

    <xs:element name="VillageSpawnDecorator">
        <xs:annotation>
            <xs:documentation>
                Spawns the player in a village, assuming the spawn point is in a valid biome for a village (plains, savannah, taiga, desert). In the absence of a way to modify the agent spawn, also spawns the agent at (0, 0).
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="test" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>


    <!--============================================== QUIT PRODUCERS ===============================================-->

    <xs:element name="ServerQuitFromTimeUp">
        <xs:annotation>
            <xs:documentation>
                Specifies a time limit that applies to all agents.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="timeLimitMs" type="xs:decimal" use="required"/>
            <xs:attribute name="description" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>

    <xs:element name="ServerQuitFromDeath">
        <xs:annotation>
            <xs:documentation>
                Specifies a time limit that applies to all agents.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="quitWhenAnyDead" type="xs:boolean" use="optional" default="false"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="ServerQuitWhenAnyAgentFinishes">
        <xs:annotation>
            <xs:documentation>
                Specifies that the mission ends when any of the agents finish.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="description" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>

    <!--=============================================================================================================-->
    <!--=========================================== CLIENT-SIDE HANDLERS ============================================-->
    <!--=============================================================================================================-->

    <!--============================================== VIDEO PRODUCERS ==============================================-->

    <xs:element name="DepthProducer">
        <xs:annotation>
            <xs:documentation>
                Requests that 32bpp depth frames be sent.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Width" type="xs:int"/>
                <xs:element name="Height" type="xs:int"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="LuminanceProducer">
        <xs:annotation>
            <xs:documentation>
                Requests an 8bpp grayscale image.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Width" type="xs:int"/>
                <xs:element name="Height" type="xs:int"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="HexColour">
        <xs:restriction base="xs:hexBinary">
            <xs:length value="3"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="MobWithColour">
        <xs:attribute name="type" type="MobList" use="required"/>
        <xs:attribute name="colour" use="required" type="HexColour"/>
    </xs:complexType>

    <xs:element name="ColourMapProducer">
        <xs:annotation>
            <xs:documentation>
                Requests a 24bpp colour map - each object/entity represented by a solid block of colour.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Width" type="xs:int"/>
                <xs:element name="Height" type="xs:int"/>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="ColourSpec" type="MobWithColour"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="skyColour" type="HexColour" default="fbceb1"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="VideoProducer">
        <xs:annotation>
            <xs:documentation>
                Requests that video frames be sent.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Width" type="xs:int"/>
                <xs:element name="Height" type="xs:int"/>
                <xs:element name="DepthScaling" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:attribute name="min" default="0">
                            <xs:simpleType>
                                <xs:restriction base="xs:decimal">
                                    <xs:minInclusive value="0"/>
                                    <xs:maxInclusive value="1"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                        <xs:attribute name="max" default="1">
                            <xs:simpleType>
                                <xs:restriction base="xs:decimal">
                                    <xs:minInclusive value="0"/>
                                    <xs:maxInclusive value="1"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                        <xs:attribute name="autoscale" type="xs:boolean" default="true">
                            <xs:annotation>
                                <xs:documentation>
                                    Set to false to specify the min and max depths manually. Default is true, where uses
                                    the min and max depths in the scene.
                                </xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="want_depth" type="xs:boolean" default="false">
                <xs:annotation>
                    <xs:documentation>
                        If true, returns depth in the fourth channel as RGBDRGBD.... Else as RGBRGB...
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="viewpoint" default="0">
                <xs:annotation>
                    <xs:documentation>
                        Sets the camera viewpoint. 0 = first-person, 1 = behind, 2 = facing.
                    </xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:int">
                        <xs:minInclusive value="0"/>
                        <xs:maxInclusive value="2"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <!--============================================== AUDIO PRODUCERS ==============================================-->

    <!--============================================= COMMAND HANDLERS ==============================================-->

    <!-- Command lists -->

    <xs:simpleType name="ContinuousMovementCommand">
        <xs:annotation>
            <xs:documentation>
                Commands for smooth movement. Some examples:

                "{{{ move 0.5}}}" - start moving forward at 50% of the normal walking speed (-ve = backward, +ve =
                forward).

                "{{{ strafe -1}}}" - start moving left at 100% of the normal walking speed (-ve = left, +ve = right).

                "{{{ pitch 0.1}}}" - start tilting the agent's head down at 10% of the maximum speed (-ve = up, +ve =
                down). The maximum speed is set by {{{ turnSpeedDegs }}} in {{{ ContinuousMovementCommands }}}.

                "{{{ turn 0.1}}}" - start turning right at 10% of the maximum speed (-ve = anti-clockwise/left, +ve =
                clockwise/right). The maximum speed is set by {{{ turnSpeedDegs }}} in {{{ ContinuousMovementCommands }}}.

                "{{{ jump 1}}}" - start jumping (1 = start, 0 = stop).

                "{{{ crouch 1}}}" - start crouching (1 = start, 0 = stop).

                "{{{ attack 1}}}" - start attacking (1 = start, 0 = stop). The 'attack' command is for destroying blocks
                and attacking mobs.

                "{{{ use 1}}}" - start 'use'ing (1 = start, 0 = stop). The 'use' command is for placing blocks and for
                other things too.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="move"/>
            <xs:enumeration value="strafe"/>
            <xs:enumeration value="pitch"/>
            <xs:enumeration value="turn"/>
            <xs:enumeration value="jump"/>
            <xs:enumeration value="crouch"/>
            <xs:enumeration value="attack"/>
            <xs:enumeration value="use"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="AbsoluteMovementCommand">
        <xs:annotation>
            <xs:documentation>
                Commands to set position and orientation directly. Some examples:

                "{{{ tp 23.5 1 -34.5}}}" - teleport the agent to the absolute position x y z (space delimited).

                "{{{ tpx 230}}}" - set the agent's x coordinate, without altering the y and z.

                "{{{ tpy 103.2}}}" - set the agent's y coordinate, without altering the x and z.

                "{{{ tpz -32.5}}}" - set the agent's z coordinate, without altering the x and y.

                "{{{ setYaw 30}}}" - set the agent's body orientation to be 30 degrees clockwise from south.

                "{{{ setPitch 20}}}" - set the agent's body orientation to be 20 degrees down from horizontal.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="tpx"/>
            <xs:enumeration value="tpy"/>
            <xs:enumeration value="tpz"/>
            <xs:enumeration value="tp"/>
            <xs:enumeration value="setYaw"/>
            <xs:enumeration value="setPitch"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="DiscreteMovementCommand">
        <xs:annotation>
            <xs:documentation>
                Commands for moving and turning in discrete increments. Some examples:

                "{{{ move 1}}}" - move the agent one block forwards (1 = forwards, -1 = backwards).

                "{{{ jumpmove 1}}}" - move the agent one block up and forwards (1 = forwards, -1 = backwards).

                "{{{ strafe 1}}}" - move the agent one block sideways (1 = right, -1 = left).

                "{{{ jumpstrafe 1}}}" - move the agent one block up and sideways (1 = right, -1 = left).

                "{{{ turn 1}}}" - rotate the agent 90 degrees right (1 = right, -1 = left).

                "{{{ movenorth 1}}}" - move the agent one block north.

                "{{{ moveeast 1}}}" - move the agent one block east.

                "{{{ movesouth 1}}}" - move the agent one block south.

                "{{{ movewest 1}}}" - move the agent one block west.

                "{{{ jumpnorth 1}}}" - move the agent one block up and north.

                "{{{ jumpeast 1}}}" - move the agent one block up and east.

                "{{{ jumpsouth 1}}}" - move the agent one block up and south.

                "{{{ jumpwest 1}}}" - move the agent one block up and west.

                "{{{ jump 1}}}" - move the agent one block up.

                "{{{ look 1}}}" - look down by 45 degrees (-ve = up, +ve = down).

                "{{{ attack 1}}}" - destroy the block that has focus.

                "{{{ use 1}}}" - place the held block item on the block face that has focus.

                "{{{ jumpuse }}}" - simultaneously jump and place the held block on the block face that has focus.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="move"/>
            <xs:enumeration value="jumpmove"/>
            <xs:enumeration value="strafe"/>
            <xs:enumeration value="jumpstrafe"/>
            <xs:enumeration value="turn"/>
            <xs:enumeration value="movenorth"/>
            <xs:enumeration value="moveeast"/>
            <xs:enumeration value="movesouth"/>
            <xs:enumeration value="movewest"/>
            <xs:enumeration value="jumpnorth"/>
            <xs:enumeration value="jumpeast"/>
            <xs:enumeration value="jumpsouth"/>
            <xs:enumeration value="jumpwest"/>
            <xs:enumeration value="jump"/>
            <xs:enumeration value="look"/>
            <xs:enumeration value="attack"/>
            <xs:enumeration value="use"/>
            <xs:enumeration value="jumpuse"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="InventoryCommand">
        <xs:annotation>
            <xs:documentation>
                Commands for changing the contents of the inventory and hotbar.

                To move items around in the inventory you can use {{{ swapInventoryItems }}}. For example, to swap
                the contents of slots 13 and 14, issue this command:

                "{{{ swapInventoryItems 13 14}}}"

                Note that inventory slots are numbered from 0 to 39.
                0-8 are the hotbar slots (which correspond to the hotbar commands hotbar.1-hotbar.9 - _note the offset_)
                9-35 are the rest of the inventory (visible when you press 'E' in the game)
                36-39 are the armour slots.

                So to move an item out of the hotbar, say:

                "{{{ swapInventoryItems 3 30}}}"

                Other commands:

                "{{{ combineInventoryItems x y}}}" - will attempt to combine the stacks in slots x and y, and leave the
                results in slot x. Eg if there are ten blocks of granite in slot 4, and 57 blocks of granite in slot 12,
                then {{{ combineInventoryItems 4 12}}} will result in 64 (the max) blocks of granite in slot 4, and the
                remainder in slot 12. If the slots can't be combined (they are different types, or the first slot is
                full) then nothing will happen.

                "{{{ discardCurrentItem }}}" - discards the currently held item.

                To select a hotbar slot:

                "{{{ hotbar.1 1}}}"
                "{{{ hotbar.1 0}}}"

                Send both commands to select hotbar slot 1 as the currently-held tool. This affects the attack and use
                commands
                - e.g. if the agent does 'use' while holding a block item it will place the block into the world.

                If the agent is currently pointed at a container item - eg a chest, shulker box, dispenser etc - then
                the swap and combine commands
                can be extended to allow access to the container's inventory. To do this, simply prefix the slot number
                with the name of the foreign
                inventory (which will be provided by the {{{ ObservationFromFullInventory }}} observations).

                So to move an item out of the hotbar and into slot 0 of a chest, say:

                "{{{ swapInventoryItems 3 Chest:0}}}"

                Note that this is the same as writing

                "{{{ swapInventoryItems Inventory:3 Chest:0}}}"

                "Inventory" is the name of the player's inventory.

                See inventory_test.py for a working example of this.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="swapInventoryItems"/>
            <xs:enumeration value="combineInventoryItems"/>
            <xs:enumeration value="discardCurrentItem"/>
            <xs:enumeration value="hotbar.1"/>
            <xs:enumeration value="hotbar.2"/>
            <xs:enumeration value="hotbar.3"/>
            <xs:enumeration value="hotbar.4"/>
            <xs:enumeration value="hotbar.5"/>
            <xs:enumeration value="hotbar.6"/>
            <xs:enumeration value="hotbar.7"/>
            <xs:enumeration value="hotbar.8"/>
            <xs:enumeration value="hotbar.9"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="SimpleCraftCommand">
        <xs:annotation>
            <xs:documentation>
                A command for simple crafting:

                "{{{ craft carpet PINK}}}"

                etc.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="craft"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="NearbyCraftCommand">
        <xs:annotation>
            <xs:documentation>
                A command for simple nearby crafting:

                "{{{ craftNearby carpet PINK}}}"

                etc.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="craftNearby"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="NearbySmeltCommand">
        <xs:annotation>
            <xs:documentation>
                A command for simple smelting:

                "{{{ smeltNearby carpet PINK}}}"

                etc.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="smeltNearby"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="EquipCommand">
        <xs:annotation>
            <xs:documentation>
                A command for equiping items in the agent's inventory:

                Will look in the agent's inventory. If the item exists, will swap that stack with the agents currently
                equiped hotbard slot.

                For basic objects, use BlockTypes found in Types.xsd. Eg:

                "{{{ equip diamond_pickaxe}}}" will attempt to equip a diamond_pickaxe from the agent's inventory.

                for more control over colours, types, etc, add a Variation or Colour. Eg:

                "{{{ equip carpet PINK}}}"
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="equip"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="PlaceCommand">
        <xs:annotation>
            <xs:documentation>
                A command for placing blocks in the agent's inventory:

                Will look in the agent's inventory. If the block exists, will try to place the block in the world.

                For basic objects, use BlockTypes found in Types.xsd. Eg:

                "{{{ place diamond_block}}}" will attempt to place a diamond block from the agent's inventory.

                for more control over colours, types, etc, add a Variation or Colour. Eg:

                "{{{ place carpet PINK}}}"
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="place"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="ChatCommand">
        <xs:annotation>
            <xs:documentation>
                A command for broadcasting text messages to the other players. An example:

                "{{{ chat I have found diamonds!}}}" - broadcasts the string "{{{ I have found diamonds!}}}".

                Chat messages from other players can be observed using {{{ ObservationFromChat }}}.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="chat"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="MissionQuitCommand">
        <xs:annotation>
            <xs:documentation>
                A command for ending the mission, example:

                "{{{ quit }}}" - terminates the current mission.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="quit"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="HumanLevelCommand">
        <xs:annotation>
            <xs:documentation>
                Commands for controlling Minecraft at the level of keyboard and mouse events.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="forward"/>
            <xs:enumeration value="left"/>
            <xs:enumeration value="back"/>
            <xs:enumeration value="right"/>
            <xs:enumeration value="jump"/>
            <xs:enumeration value="sneak"/>
            <xs:enumeration value="sprint"/>
            <xs:enumeration value="inventory"/>
            <xs:enumeration value="swapHands"/>
            <xs:enumeration value="drop"/>
            <xs:enumeration value="use"/>
            <xs:enumeration value="attack"/>
            <xs:enumeration value="pickItem"/>
            <xs:enumeration value="hotbar.1"/>
            <xs:enumeration value="hotbar.2"/>
            <xs:enumeration value="hotbar.3"/>
            <xs:enumeration value="hotbar.4"/>
            <xs:enumeration value="hotbar.5"/>
            <xs:enumeration value="hotbar.6"/>
            <xs:enumeration value="hotbar.7"/>
            <xs:enumeration value="hotbar.8"/>
            <xs:enumeration value="hotbar.9"/>
            <xs:enumeration value="moveMouse"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="Command">
        <xs:union
                memberTypes="ContinuousMovementCommand AbsoluteMovementCommand DiscreteMovementCommand InventoryCommand ChatCommand SimpleCraftCommand MissionQuitCommand HumanLevelCommand"/>
    </xs:simpleType>

    <xs:simpleType name="CommandList">
        <xs:list itemType="Command"/>
    </xs:simpleType>

    <xs:complexType name="CommandListModifier">
        <xs:annotation>
            <xs:documentation>
                Allow-list/deny-list base class - restricted by each command handler to only allow that handler's
                commands.
            </xs:documentation>
        </xs:annotation>
        <xs:choice maxOccurs="unbounded">
            <xs:element name="command" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
        <xs:attribute name="type" use="optional" default="deny-list">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="deny-list"/>
                    <xs:enumeration value="allow-list"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
    </xs:complexType>

    <!-- The actual command handlers.-->

    <xs:element name="ContinuousMovementCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands that control smooth movement.

                Commands take the form of "verb &lt;value&gt;" e.g. "{{{ move 1}}}" to move forwards with normal speed.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="ContinuousMovementCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
            <xs:attribute name="turnSpeedDegs" type="xs:decimal" use="optional" default="180">
                <xs:annotation>
                    <xs:documentation>
                        This sets the maximum speed for both turning the agent and adjusting the camera pitch, in
                        degrees per second.

                        The turn and pitch command values are both scaled by this - eg "{{{ turn -0.5}}}" to turn left
                        (anti-clockwise) at half this maximum speed.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:element name="AbsoluteMovementCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands to set the player's position and orientation directly.

                Commands take the form of "verb &lt;value&gt;" e.g. "{{{ tpx 13}}}" to set the x-coordinate to 13.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="AbsoluteMovementCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="DiscreteMovementCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands that control movement in discrete jumps.

                Commands take the form of "verb &lt;value&gt;" e.g. "{{{ move 1}}}" to move forwards one square.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="DiscreteMovementCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
            <xs:attribute name="autoFall" type="xs:boolean" use="optional" default="false"/>
            <xs:attribute name="autoJump" type="xs:boolean" use="optional" default="false"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="InventoryCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands that control the player's inventory.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="InventoryCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="SimpleCraftCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept simple commands that implement a basic form of crafting.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ViewToCraft" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false"/>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="SimpleCraftCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="NearbyCraftCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept simple commands that implement a basic form of crafting. Success of
                the craft command depends on the presence of a nearby crafting table previously placed by the agent and
                within reach and in field of view.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ViewToCraft" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false"/>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="NearbyCraftCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="NearbySmeltCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept simple commands that implement a basic form of smelting. Success of
                the smelt command depends on the presence of a nearby furnace previously placed by the agent and within
                reach and in field of view. Fails when a command corresponds to an item not able to be smelted. Each
                command takes fuel as if the agent had placed the items in a furnace.

                Eg:

                If called on 16 iron ore, requires 2 coal, 2 charcoal, 11 planks, etc.

                If called twice separately on 8 iron ore, requires 1 coal and then 1 coal, etc.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ViewToSmelt" type="xs:boolean" minOccurs="0" maxOccurs="1" default="false"/>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="NearbySmeltCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="EquipCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands that allow for equiping items of a given type in the players
                inventory. If the specified block is contained in the agent's inventory, then the agent will attempt
                to swap it to the current hotbar slot.

                If a non-block is specified, the command fails.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="EquipCommand" minOccurs="0" maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="PlaceCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands that allow for the placement of blocks. If the specified
                block is contained in the agent's inventory, then the agent will attempt to place the block in the
                world.

                If a non-block is specified, the command fails.

                If a block is specified, the block will swap to the hotbar, be placed, and then swapped back, so no
                changes to the inventory are made besides losing a block.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="PlaceCommand" minOccurs="0" maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="ChatCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands that send chat messages to the other players.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="ChatCommand" minOccurs="0" maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="MissionQuitCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept a command that quits the mission.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="MissionQuitCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
            <xs:attribute name="quitDescription" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>

    <xs:element name="TurnBasedCommands">
        <xs:annotation>
            <xs:documentation>
                Allows a user to specify that certain commands must be sent on a turn-by-turn basis - ie, in a
                multi-agent mission, placing the {{{ DiscreteMovementCommand }}} handler inside the TurnBasedCommands
                section will mean that each agent must take it in turns to send a discrete movement command. See
                turn_based_test.py in the Python Samples for a demonstration/explanation of this.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:group ref="TurnBasedApplicableCommandHandlers"/>
            <xs:attribute name="requestedPosition">
                <xs:simpleType>
                    <xs:restriction base="xs:integer">
                        <xs:minInclusive value="0"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:element name="HumanLevelCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept commands on the level of mouse and keyboard events.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="ModifierList" minOccurs="0" maxOccurs="1">
                    <xs:complexType>
                        <xs:complexContent>
                            <xs:restriction base="CommandListModifier">
                                <xs:choice maxOccurs="unbounded">
                                    <xs:element name="command" type="HumanLevelCommand" minOccurs="0"
                                                maxOccurs="unbounded"/>
                                </xs:choice>
                            </xs:restriction>
                        </xs:complexContent>
                    </xs:complexType>
                </xs:element>
            </xs:all>
        </xs:complexType>
    </xs:element>

    <xs:element name="PauseCommand">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will accept the pause command for payusing missions.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="CameraCommands">
        <xs:annotation>
            <xs:documentation>
                This command accepts camera commands. The command is "camera {yaw} {pitch}"
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>
    <!--=========================================== OBSERVATION PRODUCERS ===========================================-->

    <xs:element name="ObservationFromRecentCommands">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that say what commands have been acted on since the last
                report, in the JSON element {{{ CommandsSinceLastObservation }}}.

                Note that the commands returned might not yet have taken effect, depending on the command and the way in
                which Minecraft responds to it -
                but they will have been processed by the command handling chain.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromAchievements">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that corespond to each achievemnet available in game.
                IMPORTANT - given Malmo by-passes the Gui for most events this handler will attempt to give the player
                the OPEN_INVENTORY acheivemnt to not prevent the accumulation of later achievemnts.

                Achievemnts will be returned as individual entires with a boolean value under the property key
                "achievements"

            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromEquippedItem">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return an observation of the equipped item by the agent along with its item
                durribility if available.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromTurnScheduler">
        <xs:annotation>
            <xs:documentation>
                Automatically addd by Malmo when the user specifies the {{{ TurnBasedCommands }}} handler. This provides
                vital observations back to the agent to allow them to make use of the turn scheduler. When it is the
                agent's turn, the JSON will contain {{{ turn_number }}} - an integer which tracks the number of turns
                the
                agent has taken, and {{{ turn_key }}} - a one-shot key which must be passed back to Malmo as a parameter
                in {{{ sendCommand }}} in order for the command to be accepted.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromSubgoalPositionList">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that indicate the direction to follow to the next
                subgoal.
                The value to turn by is returned in the JSON element {{{ yawDelta }}}.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Point" type="PointWithToleranceAndDescription" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="ObservationFromHotBar">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that say what is in the hotbar.

                Up to four values are returned for each slot, if not empty: e.g. {{{ Hotbar_1_size }}} and
                {{{ Hotbar_1_item }}} containing the number and
                type of the item(s) in the slot, respectively, and {{{ Hotbar_1_colour }}} and {{{ Hotbar_1_variant }}}
                if
                the item has a colour/variation. Hotbar slots are numbered 0 to 8 inclusive.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromFullStats">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return several observations:

                * Achievement statistics: {{{ DistanceTravelled }}}, {{{ TimeAlive }}}, {{{ MobsKilled }}},
                {{{ PlayersKilled }}}, {{{ DamageTaken }}}, {{{ DamageDealt }}}
                * Life statistics: {{{ Life }}}, {{{ Score }}}, {{{ Food }}}, {{{ Air }}}, {{{ XP }}}, {{{ IsAlive }}},
                {{{ Name }}}
                * Position statistics: {{{ XPos }}}, {{{ YPos }}}, {{{ ZPos }}}, {{{ Pitch }}}, {{{ Yaw }}}
                * Environment statistics: {{{ WorldTime }}} - current time in ticks, {{{ TotalTime }}} - total world
                time,
                unaffected by ServerInitialConditions
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromHuman">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return low-level keyboard and mouse events.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromSystem">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return information on the current performance of the Minecraft system - eg
                tick speeds, etc.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromDamage">
        <xs:annotation>
            <xs:documentation>
                When present, the mod will return a JSON object called "damage_source", containing the observation
                "is_dead" telling if the player is dead. Additionally, if there was an unprocessed damage event, there
                are a number of additional fields returned to inform us of the location, type of damage, amount of damage
                entity responsible, and if the damage has various types such as fire or magic. See
                ObservationFromDamageImplementation.java for the complete list. Note some fields are only present if non-
                null.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromRay">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return a JSON object called "LineOfSight", containing observations about the
                block or entity which is currently in the centre of the screen:

                * Hit details: {{{ hitType }}} - will be "block" for a block, "entity" for an entity (eg spider, rabbit
                etc) or "item" for a free-floating item that can be picked up. {{{ inRange }}} will be true if the
                block/entity is within the agent's reach - ie attacking or using will have an effect on the object.
                {{{ distance }}} gives the straight-line distance from the agent.
                * Position: {{{ x }}}, {{{ y }}}, {{{ z }}} - in the case of block hits, will be the precise point when
                the
                ray intercepts the block. {{{ yaw }}}, {{{ pitch }}} are also added for entities.
                * Type information: {{{ type }}}, {{{ colour }}}, {{{ variant }}}, {{{ facing }}}
                * Extra properties: in the case of block types, any extra properties will be returned by their minecraft
                name, prefixed with "prop_" (eg, for leaves, "prop_decayable" and "prop_check_decay") - this is the same
                data as can be seen by exploring Minecraft with the F3 debug information displayed. For floating items,
                the stack size is returned in {{{ stackSize }}}
                * NBTTagCompound: for tile entity blocks, optionally returns a json object called "NBTTagCompound" which
                contains the entity's entire NBTTagCompound - eg useful for reading the text off signs, etc. Set
                {{{ includeNBT }}} to true to receive this data.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="includeNBT" type="xs:boolean" use="optional" default="false"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="ObservationFromFullInventory">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that describe the contents of the player's inventory.
                There are two modes - "flat" (the default) is provided for backwards compatibility, and behaves like
                this:

                The inventory contents are returned in a flat format in the root of the json observations.
                Up to four values are returned for each slot, if not empty: e.g. {{{ InventorySlot_0_size }}} and
                {{{ InventorySlot_0_item }}} containing the number and
                type of the item(s) in the slot, respectively, and {{{ InventorySlot_0_colour }}} and
                {{{ InventorySlot_0_variant }}} if the item has a colour/variation.
                Inventory slots are numbered 0 to 39 inclusive.
                If there is a container item available (eg the player is pointed at a chest), this will be returned in
                the same way, but "InventorySlot"
                will be replaced by "ContainerNameSlot" - eg {{{ ShulkerBoxSlot_0_item }}} etc.

                If {{{ flat }}} is false (recommended), the data is returned as an array of objects, one for each item
                in
                the inventory/inventories.
                The JSON array is called "inventory", and each item in the array will contain:
                * {{{ type }}} - the type of the object in that ItemStack
                * {{{ colour }}} - the colour, if relevant
                * {{{ variant }}} - the variant, if relevant
                * {{{ quantity }}} - the number of objects in the ItemStack
                * {{{ index }}} - the slot number
                * {{{ inventory }}} - the name of the inventory - will be "Inventory" for the player, or, for example,
                "ShulkerBox", "Chest" etc, if a container is available.
                This index and inventory information can be used to specify the item in the {{{ InventoryCommands }}} -
                items are specified as inventory:index -
                eg "ShulkerBox:12"

                In addition to this information, whether {{{ flat }}} is true or false, an array called
                "inventoriesAvailable" will also be returned.
                This will contain a list of all the inventories available (usually just the player's, but if the player
                is pointed at a container, this
                will also be available.)
                For each inventory, an object will be returned that specifies:
                * {{{ name }}} - the inventory name (same as will be returned in the {{{ inventory }}} field for any
                items
                in that inventory)
                * {{{ size }}} - the number of slots the inventory provides.

                For a working example please see inventory_test.py in the Python samples folder.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="flat" type="xs:boolean" use="optional" default="true"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="ObservationFromDiscreteCell">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return an observation of the player's position that is unique for every cell
                on the x/z plane.
                This is useful for discrete-movement missions where we need to uniquely identify their location but
                don't mind how.

                The observation will contain the JSON element {{{ cell }}} containing e.g. {{{ (2,4) }}} if the player
                is
                standing at any location where
                x = 2 and z = 4.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:complexType name="NamedPoint">
        <xs:complexContent>
            <xs:extension base="Pos">
                <xs:attribute name="name" type="xs:Name" use="required"/>
                <!-- ObservationFromDistance handler will return JSON with property "distanceFrom<name>" -->
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:element name="ObservationFromDistance">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return an observation that specifies the distance to a named location.

                A JSON element {{{ distanceFromNAME }}} will be returned (where {{{ NAME }}} is replaced with the name
                of
                the NamedPoint),
                with a value that is the distance.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Marker" type="NamedPoint"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="GridDefinition">
        <xs:annotation>
            <xs:documentation>
                {{{ name }}} - Each grid has a text label to identify it.

                {{{ absoluteCoords }}} - If true, the min and max coordinates of the grid are interpreted as world
                coordinates. If false (the default)
                then the coordinates are relative to the player.
                {{{ projectDown }}} if true, generate a 2d top-down projection; that is, take a top-most non-air
                block for each x and z position
                {{{ atSpawn }}} if true, coordinates are given relative to world spawn point

                {{{ min }}}, {{{ max }}} - The corners of the grid.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="min" type="Pos"/>
            <xs:element name="max" type="Pos"/>
        </xs:sequence>
        <xs:attribute name="name" type="xs:Name" use="required"/>
        <xs:attribute name="absoluteCoords" type="xs:boolean" use="optional" default="false"/>
        <xs:attribute name="projectDown" type="xs:boolean" use="optional" default="false"/>
        <xs:attribute name="atSpawn" type="xs:boolean" use="optional" default="false"/>
    </xs:complexType>

    <xs:element name="ObservationFromGrid">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that say what the nearby blocks are.

                For each {{{ Grid }}} entry, a named JSON element will be returned with a 1D array of block types, in
                order along the x, then z, then y axes.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Grid" type="GridDefinition"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="RayOffset">
        <xs:annotation>
            <xs:documentation>
                An offset with 3 degrees of freedom for specifying offsets from PlayerLookVec for raytracing
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="pitch" type="xs:float" use="required"/>
        <xs:attribute name="yaw" type="xs:float" use="required"/>
        <xs:attribute name="distance" type="xs:float" use="required"/>
    </xs:complexType>

    <xs:element name="ObservationFromRichLidar">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return rich information on what each specified ray reflects off of.
                Rays are traced both at the block layer and the entity layer meaning two individual distances are returned

                For each {{{ Ray }}} entry, an additional rich LIDAR observation will be appended to the json element
                Rich LIDAR observations are 12 consecutive numbers corresponding to distances and properties of the hit
                entities and blocks
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="RayOffset" type="RayOffset" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="RangeDefinition">
        <xs:annotation>
            <xs:documentation>
                Used by {{{ ObservationFromNearbyEntities }}}. Defines the range within which entities will be returned.
                Eg a range of 10,1,10 will return all entities within +/-10 blocks of the agent in the x and z axes, and
                within +/-1 block vertically.

                {{{ update_frequency }}} is measured in Minecraft world ticks, and allows the user to specify how often
                they would like to receive each observation. A value of 20, under normal Minecraft running conditions,
                for example, would return the entity list once per second.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="name" type="xs:Name" use="required"/>
        <xs:attribute name="xrange" type="xs:decimal" use="required"/>
        <xs:attribute name="yrange" type="xs:decimal" use="required"/>
        <xs:attribute name="zrange" type="xs:decimal" use="required"/>
        <xs:attribute name="update_frequency" type="xs:int" use="optional" default="1"/>
    </xs:complexType>

    <xs:element name="ObservationFromNearbyEntities">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that list the positions of all entities that fall within
                the given ranges of the agent.

                A JSON array will be returned for each range requested, named using the {{{ name }}} attribute of the
                range. Within the array will be a series of elements, one for each entity, containing the following:

                - name: a string describing the entity (eg from Types.xsd)

                - x: the x position of the entity

                - y: the y position of the entity

                - z: the z position of the entity

                - quantity: if items have been grouped together by Minecraft, this indicates the number in the stack

                - colour: if the item is a tile entity, with a colour, this will be present to describe the colour

                - variation: optional string to describe the variation - eg the type of egg, or brick, etc (see
                Types.xsd)
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Range" type="RangeDefinition"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="ObservationFromChat">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that say what chat messages have occurred and from which
                player.
                It will also return messages for any title or subtitle change (eg via Minecraft's title command)

                A JSON element {{{ Chat }}} will be returned, with a list of chat strings.
                In the same way, title changes and subtitle changes will be returned in {{{ Title }}} and
                {{{ Subtitle }}}
                respectively.

                Note that unless the AgentHost ObservationsPolicy is set to KEEP_ALL_OBSERVATIONS it is likely that chat
                messages will be missed.
                The default policy is LATEST_OBSERVATION_ONLY.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>

    <xs:element name="ObservationFromCompass">
        <xs:annotation>
            <xs:documentation>
                When present, the Mod will return observations that detail how the agent is facing and what position the
                agent is in with respect to a compass.

                A JSON element will be returned for the compass in the agent's inventory. The JSON will contain the
                following

                - set: boolean on whether the compass is set

                - compass-x: the x coordinate value of the set compass, null if not set

                - compass-y: the y coordinate value of the set compass, null if not set

                - compass-z: the z coordinate value of the set compass, null if not set

                - relative-x: the relative x coordinate value of the player to the compass, null if not set

                - relative-y: the relative y coordinate value of the player to the compass, null if not set

                - relative-z: the relative z coordinate value of the player to the compass, null if not set

                - offset: the number of degrees the agent is facing away from the direction the compass is pointing

                - normalized-offset: the number of degrees the agent is facing away, with the agent considered 0 degrees

                - distance: the distance from the agent's location to the compass's location
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>


    <xs:element name="FileBasedPerformanceProducer">
        <xs:annotation>
            <xs:documentation>
                When present, writes reward performance and number of samples to a directory.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType/>
    </xs:element>


    <!--============================================= REWARD PRODUCERS ==============================================-->

    <xs:simpleType name="Dimension">
        <xs:annotation>
            <xs:documentation>
                For multi-dimensional rewards, specifies the dimension to allocate this reward to. All rewards on this
                dimension will be summed.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:int">
            <xs:minInclusive value="0"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:attributeGroup name="RewardProducerAttributes">
        <!-- Common attributes that are shared by all reward producers. -->
        <xs:attribute name="dimension" type="Dimension" use="optional" default="0"/>
    </xs:attributeGroup>

    <xs:complexType name="PointWithReward">
        <xs:complexContent>
            <xs:extension base="Pos">
                <xs:attribute name="reward" type="xs:decimal" use="required"/>
                <xs:attribute name="tolerance" type="xs:decimal" use="required"/>
                <xs:attribute name="oneshot" type="xs:boolean" use="optional" default="true"/>
                <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="MobWithReward">
        <xs:attribute name="type" type="MobList" use="required"/>
        <xs:attribute name="reward" type="xs:decimal" use="required"/>
        <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
    </xs:complexType>

    <xs:element name="RewardForDamagingEntity">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when an entity is damaged.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Mob" type="MobWithReward"/>
            </xs:choice>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="RewardForReachingPosition">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when a specified position is reached by the agent.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Marker" type="PointWithReward"/>
            </xs:choice>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="BlockSpec">
        <xs:attribute name="type" use="required" type="BlockList"/>
        <xs:attribute name="amount" use="optional" type="xs:int" default="1"/>
        <xs:attribute name="variant" use="optional" type="VariantList"/>
        <xs:attribute name="colour" use="optional" type="ColourList"/>
    </xs:complexType>

    <xs:complexType name="BlockOrItemSpec">
        <xs:attribute name="type" use="required" type="BlockOrItemList"/>
        <xs:attribute name="amount" use="optional" type="xs:int" default="1"/>
        <xs:attribute name="variant" use="optional" type="VariantList"/>
        <xs:attribute name="colour" use="optional" type="ColourList"/>
    </xs:complexType>

    <xs:complexType name="BlockSpecWithRewardAndBehaviour">
        <xs:complexContent>
            <xs:extension base="BlockSpec">
                <xs:attribute name="reward" use="required" type="xs:decimal"/>
                <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
                <xs:attribute name="behaviour" type="Behaviour" use="optional" default="oncePerBlock"/>
                <xs:attribute name="cooldownInMs" type="xs:decimal" use="optional" default="1000"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="BlockOrItemSpecWithReward">
        <xs:complexContent>
            <xs:extension base="BlockOrItemSpec">
                <xs:attribute name="reward" use="required" type="xs:decimal"/>
                <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:simpleType name="Behaviour">
        <xs:restriction base="xs:string">
            <xs:enumeration value="onceOnly"/>
            <xs:enumeration value="oncePerBlock"/>
            <xs:enumeration value="oncePerTimeSpan"/>
            <xs:enumeration value="constant"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="RewardForTouchingBlockType">
        <xs:annotation>
            <xs:documentation>
                Sends a rewards when an agent comes in contact with a specific block type.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Block" type="BlockSpecWithRewardAndBehaviour"/>
            </xs:choice>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="RewardForSendingCommand">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent issues a command.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="reward" type="xs:decimal" use="optional" default="-1.0"/>
            <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="ChatMatchSpec">
        <xs:attribute name="description" use="required" type="xs:string"/>
        <xs:attribute name="reward" use="required" type="xs:decimal"/>
        <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
        <xs:attribute name="regex" use="required" type="xs:string"/>
    </xs:complexType>

    <xs:element name="RewardForSendingMatchingChatMessage">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent sends a chat message that matches a given regular expression (supports
                Java regex syntax).
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="ChatMatch" type="ChatMatchSpec"/>
            </xs:choice>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="ItemSpec">
        <xs:attribute name="reward" use="required" type="xs:decimal"/>
        <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
        <xs:attribute name="type" use="required" type="BlockOrItemList"/>
    </xs:complexType>

    <xs:element name="RewardForCollectingItem">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent collects a specific item.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithReward"/>
            </xs:choice>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="RewardForCollectingItemQuantity">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent collects a specific item.

                If Sparse is set to true, will only give full reward on collecting entire amount.

                Otherwise, will give the reward amount notated for each item collected up to the amount noted.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithReward"/>
            </xs:choice>
            <xs:attribute name="sparse" type="xs:boolean" use="optional" default="true"/>
            <xs:attribute name="once" type="xs:boolean" use="optional" default="false"/>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="RewardForPossessingItem">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent collects a specific item amount.

                If Sparse is set to true, will only give reward once, when the agent first possesses the entire amount.

                Otherwise, will give the reward amount notated every time a multiple of the specified amount is
                possessed.

                If excludeLoops is set to true, will only give reward for possesion if the maximum the agent has
                previously
                attained is increaded, and that increse crosses a multiple of the specified amount. (Note this only
                applies
                when sparse is set to false - when sparse is true this has no effect)
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithReward"/>
            </xs:choice>
            <xs:attribute name="sparse" type="xs:boolean" use="optional" default="true"/>
            <xs:attribute name="excludeLoops" type="xs:boolean" use="optional" default="true"/>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="RewardForCraftingItem">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent crafts a specific item.

                If Sparse is set to true, will only give full reward on crafting of entire amount.

                Otherwise, will give the reward amount notated for each item crafted up to the amount noted.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithReward"/>
            </xs:choice>
            <xs:attribute name="Sparse" type="xs:boolean" use="optional" default="true"/>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="RewardForSmeltingItem">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent smelts a specific item.

                If Sparse is set to true, will only give full reward on crafting of entire amount.

                Otherwise, will give the reward amount notated for each item crafted up to the amount noted.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithReward"/>
            </xs:choice>
            <xs:attribute name="Sparse" type="xs:boolean" use="optional" default="true"/>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="RewardForDiscardingItem">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when an agent discards a specific item.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithReward"/>
            </xs:choice>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="MissionEndRewardCase">
        <xs:attribute name="reward" use="required" type="xs:decimal"/>
        <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
        <xs:attribute name="description" use="required" type="xs:string"/>
    </xs:complexType>

    <xs:element name="RewardForMissionEnd">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the mission ends for a specified reason.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Reward" type="MissionEndRewardCase"/>
            </xs:choice>
            <xs:attribute name="rewardForDeath" type="xs:decimal" use="optional" default="0.0"/>
            <xs:attribute name="rewardForDeathDistribution" type="xs:string" use="optional" default=""/>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="RewardDensityForBuildAndBreak">
        <xs:annotation>
            <xs:documentation>
                Reward type for {{{ RewardForStructureCopying }}}:

                - {{{ PER_BLOCK }}} - reward will be given whenever a block is placed/destroyed in the goal volume, and
                will be determined by {{{ RewardScale }}}. An additional reward of {{{ RewardForCompletion }}} will be
                added
                the *first* time the copy is correctly completed.

                - {{{ MISSION_END }}} - no reward will be given until the mission ends. Reward will be scaled from 0-1,
                where 0 means "no blocks correct" and 1 means "all blocks correct", and then multipled by
                {{{ RewardScale }}}.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="PER_BLOCK"/>
            <xs:enumeration value="MISSION_END"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="UnnamedGridDefinition">
        <xs:sequence>
            <xs:element name="min">
                <xs:complexType>
                    <xs:attribute name="x" type="xs:int" use="required"/>
                    <xs:attribute name="y" type="xs:int" use="required"/>
                    <xs:attribute name="z" type="xs:int" use="required"/>
                </xs:complexType>
            </xs:element>
            <xs:element name="max">
                <xs:complexType>
                    <xs:attribute name="x" type="xs:int" use="required"/>
                    <xs:attribute name="y" type="xs:int" use="required"/>
                    <xs:attribute name="z" type="xs:int" use="required"/>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:element name="RewardForStructureCopying">
        <xs:annotation>
            <xs:documentation>
                Sends a reward when the agent copies blocks from a given structure.

                NOTE: This will do nothing unless you have set up a {{{ BuildBattleDecorator }}} on the server.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:all>
                <xs:element name="RewardDensity" type="RewardDensityForBuildAndBreak"/>
                <xs:element name="AddQuitProducer" minOccurs="0" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation>
                            If present, the mission will end when the copy exactly matches the original. Set
                            {{{ description }}} to the quit code you'd like to receive when this happens. (See
                            {{{ RewardForMissionEnd }}}.)
                        </xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:attribute name="description" type="xs:string" use="optional" default=""/>
                    </xs:complexType>
                </xs:element>
            </xs:all>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
            <xs:attribute name="rewardScale" type="xs:decimal" use="optional" default="5.0">
                <xs:annotation>
                    <xs:documentation>
                        This is the reward to be added or deducted for each block event.

                        The rewards are calculated as follows:
                        - For destroying a correct block: -1 * rewardScale
                        - For destroying an incorrect block: +1 * rewardScale
                        - For placing a correct block: +1 * rewardScale
                        - For placing an incorrect block: -1 * rewardScale

                        If {{{ RewardDensity }}} is set to {{{ {PER_BLOCK }}}, this reward will arrive after each block
                        transaction. If it's set to {{{ MISSION_END }}}, the individual rewards will not be sent, but
                        will
                        be summed throughout the course of the mission, and the resulting total will be sent as the
                        final reward.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="rewardDistribution" type="xs:string" use="optional" default=""/>
            <xs:attribute name="rewardForCompletion" type="xs:decimal" use="optional" default="200.0">
                <xs:annotation>
                    <xs:documentation>
                        This is the extra reward to be added when the copy exactly matches the original. (Will only be
                        applied once.)
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="RewardDensityForTimeTaken">
        <xs:annotation>
            <xs:documentation>
                Reward type for {{{ RewardForTimeTaken }}}:

                - {{{ PER_TICK }}} - only the reward delta will be sent as a reward, at each tick. The initial reward
                will
                be ignored.

                - {{{ PER_TICK_ACCUMULATED }}} - the initial reward will be adjusted by the delta at each tick, and the
                current total sent. Eg: if the initial reward is 1000 and the delta is -1, the agent will receive
                rewards of 1000,999,998,997 for the first four ticks.

                - {{{ MISSION_END }}} - the initial reward will be adjusted by the delta at each tick, but no reward
                will
                be sent until the mission ends. Eg: if the initial reward is 1000, the delta is -1, and the mission runs
                for 800 ticks, then final reward sent will be 200.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="PER_TICK"/>
            <xs:enumeration value="PER_TICK_ACCUMULATED"/>
            <xs:enumeration value="MISSION_END"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="RewardForTimeTaken">
        <xs:annotation>
            <xs:documentation>
                Reward that is dependent on time. Can be received per tick, or just once at the end.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
            <xs:attribute name="initialReward" type="xs:decimal" use="required"/>
            <xs:attribute name="delta" type="xs:decimal" use="required"/>
            <xs:attribute name="density" type="RewardDensityForTimeTaken" use="required"/>
            <xs:attribute name="rewardDistribution" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="RewardDensityForDistanceTraveledToCompassTarget">
        <xs:annotation>
            <xs:documentation>
                Reward type for {{{ RewardForDistanceTraveledToCompassTarget }}}:

                <xs:simpleType name="Command">
                    <xs:union
                            memberTypes="ContinuousMovementCommand AbsoluteMovementCommand DiscreteMovementCommand InventoryCommand ChatCommand SimpleCraftCommand NearbyCraftCommand NearbySmeltCommand MissionQuitCommand HumanLevelCommand"/>
                </xs:simpleType>

                - {{{ PER_TICK_ACCUMULATED }}} - the reward will be adjusted by the delta at each tick, and the current
                total sent. E.G. If the agent moves forward to the target and then back to start the reward will be 0

                - {{{ MISSION_END }}} - the reward will be adjusted by the delta at each tick, but no reward will be
                sent
                until the mission ends. Eg: if the initial reward is 1000, the delta is -1, and the mission runs for 800
                ticks, then final reward sent will be 200.
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="PER_TICK"/>
            <xs:enumeration value="PER_TICK_ACCUMULATED"/>
            <xs:enumeration value="MISSION_END"/>
        </xs:restriction>
    </xs:simpleType>

    <xs:element name="RewardForDistanceTraveledToCompassTarget">
        <xs:annotation>
            <xs:documentation>
                Reward that is dependent on distance to compass target. Can be received per tick, or just once at the
                end.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
            <xs:attribute name="rewardPerBlock" type="xs:decimal" use="required"/>
            <xs:attribute name="density" type="RewardDensityForDistanceTraveledToCompassTarget" use="required"/>
            <xs:attribute name="rewardDistribution" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="MobWithDescriptionAndReward">
        <xs:complexContent>
            <xs:extension base="MobWithDescription">
                <xs:attribute name="reward" use="required" type="xs:decimal"/>
                <xs:attribute name="distribution" type="xs:string" use="optional" default=""/>
                <xs:attribute name="oneshot" type="xs:boolean" use="optional" default="true"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:element name="RewardForCatchingMob">
        <xs:annotation>
            <xs:documentation>
                Reward for cornering a mob, such that it cannot move from its current square without passing through an
                agent.
                If {{{ global }}} is true then the agent doesn't have to be involved in catching the mob; otherwise they
                must be adjacent to the mob.
                For our purposes, a mob is deemed "caught" if there are no unoccupied air blocks immediately north,
                south, east or west of them for them to move into. (An air block is considered occupied if there is an
                agent standing in it.) This does not necessarily correspond to Minecraft's definition of caught, in
                which mobs can escape by jumping or passing through agents.
                If {{{ oneshot }}} is true, the reward will only be counted once per entity.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Mob" type="MobWithDescriptionAndReward"/>
            </xs:choice>
            <xs:attributeGroup ref="RewardProducerAttributes"/>
        </xs:complexType>
    </xs:element>

    <!--============================================== QUIT PRODUCERS ===============================================-->

    <xs:complexType name="PointWithToleranceAndDescription">
        <xs:complexContent>
            <xs:extension base="Pos">
                <xs:attribute name="tolerance" type="xs:decimal" use="optional" default="0.5"/>
                <xs:attribute name="description" type="xs:string" use="optional" default=""/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="BlockSpecWithDescription">
        <xs:complexContent>
            <xs:extension base="BlockSpec">
                <xs:attribute name="description" type="xs:string" use="optional" default=""/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="BlockOrItemSpecWithDescription">
        <xs:complexContent>
            <xs:extension base="BlockOrItemSpec">
                <xs:attribute name="description" type="xs:string" use="optional" default=""/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:element name="AgentQuitFromReachingPosition">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when they reach a specified position.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Marker" type="PointWithToleranceAndDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="AgentQuitFromTimeUp">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when a certain amount of time has elapsed.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="timeLimitMs" type="xs:decimal" use="required"/>
            <xs:attribute name="description" type="xs:string" use="optional" default=""/>
        </xs:complexType>
    </xs:element>

    <xs:element name="AgentQuitFromDeath">
        <xs:annotation>
            <xs:documentation>
                Allows the agent to quit on death. If not specified, agents will respawn per vanilla spawn mechanics.
                Sets the quit code of the agent based on how the agent died, e.g. "lava", "cactus", "flyIntoWall"
            </xs:documentation>
        </xs:annotation>
    </xs:element>

    <xs:element name="AgentQuitFromTouchingBlockType">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when they come in contact with a specified block
                type.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Block" type="BlockSpecWithDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="AgentQuitFromCollectingItem">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when they collect (or craft) a specified item.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="AgentQuitFromCollectingItemQuantity">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when they collect (or craft) a specified number of
                the item.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="AgentQuitFromCraftingItem">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when they craft a specified item.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="AgentQuitFromSmeltingItem">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when they smelt a specified item.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:element name="AgentQuitFromPossessingItem">
        <xs:annotation>
            <xs:documentation>
                When this is included the agent's mission will end when they possess the specified item in their
                inventory all at once.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Item" type="BlockOrItemSpecWithDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:simpleType name="MobList">
        <xs:list itemType="EntityTypes"/>
    </xs:simpleType>

    <xs:complexType name="MobWithDescription">
        <xs:attribute name="type" type="MobList" use="required"/>
        <xs:attribute name="description" type="xs:string" use="optional" default=""/>
        <xs:attribute name="global" type="xs:boolean" use="optional" default="false"/>
    </xs:complexType>

    <xs:element name="AgentQuitFromCatchingMob">
        <xs:annotation>
            <xs:documentation>
                Agent's mission will end when they corner a mob. If {{{ global }}} is true then the agent doesn't have
                to
                be involved in catching the mob; otherwise they must be adjacent to the mob.
                For our purposes, a mob is deemed "caught" if there are no unoccupied air blocks immediately north,
                south, east or west of them for them to move into. (An air block is considered occupied if there is an
                agent standing in it.) This does not necessarily correspond to Minecraft's definition of caught, in
                which mobs can escape by jumping or passing through agents.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element name="Mob" type="MobWithDescription"/>
            </xs:choice>
        </xs:complexType>
    </xs:element>

    <xs:complexType name="CommandQuota">
        <xs:annotation>
            <xs:documentation>
                Set up a quota for a group of commands. {{{ AgentQuitFromReachingCommandQuota }}} will fire once the
                quota
                is exceeded.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="commands" use="required" type="CommandList">
            <xs:annotation>
                <xs:documentation>
                    List of commands, separated by spaces, that will share this quota. Commands must be valid members of
                    {{{ ContinuousMovementCommand }}}, {{{ AbsoluteMovementCommand }}}, {{{ DiscreteMovementCommand }}},
                    {{{ InventoryCommand }}}, or {{{ ChatCommand }}}.

                    For instance, if the command list contains {{{ moveeast }}}, {{{ movenorth }}}, {{{ movesouth }}}
                    and
                    {{{ movewest }}}, then the mission will end once the summed total usage of all four commands reaches
                    the quota - even if the agent never used {{{ movesouth }}}.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="quota" use="required" type="xs:int">
            <xs:annotation>
                <xs:documentation>
                    Total number of usages allocated for this command group.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description" type="xs:string" use="optional" default="">
            <xs:annotation>
                <xs:documentation>
                    String that will be returned from the {{{ AgentQuitFromReachingCommandQuota }}} if this quota is
                    reached. This can be used in {{{ RewardForMissionEnd }}}, and is also returned in the
                    {{{ MissionEnded }}} message.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:element name="AgentQuitFromReachingCommandQuota">
        <xs:annotation>
            <xs:documentation>
                Count the commands acted on by the Mod, and signal the end of the mission when the defined quota of
                commands has been reached.

                A total number of commands can be specified, and/or groups of commands can be given their own quota.
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="Quota" type="CommandQuota"/>
            </xs:choice>
            <xs:attribute name="total" type="xs:int" use="optional">
                <xs:annotation>
                    <xs:documentation>
                        Total number of commands allowed before the mission ends. (Note that a command must be acted on
                        to be counted - sending malformed commands won't affect the total.)

                        The check for total command use takes precedence over the individual group quotas, if used.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="description" type="xs:string" use="optional" default="">
                <xs:annotation>
                    <xs:documentation>
                        String that will be returned from the {{{ AgentQuitFromReachingCommandQuota }}} if the total
                        allowed command usage is reached. This can be used in {{{ RewardForMissionEnd }}}, and is also
                        returned in the {{{ MissionEnded }}} message.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>

</xs:schema>
